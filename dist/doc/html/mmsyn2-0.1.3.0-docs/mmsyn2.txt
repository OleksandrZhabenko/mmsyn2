-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | The library that can be used for optimization of multiple (Ord a) => a -> b transformations
--   
--   The library that can be used for optimization of multiple (Ord a)
--   =&gt; a -&gt; b transformations
@package mmsyn2
@version 0.1.3.0

module CaseBi

-- | The function that can be used instead of the 'case ... of' function
--   
--   <pre>
--   case var of
--     a1 -&gt; b1
--     a2 -&gt; b2
--     a3 -&gt; b3
--     ...
--     an -&gt; bn
--     _  -&gt; defaultValue
--   </pre>
--   
--   The function 'case a of ...' gives the <i>O(n)</i> coplexity of the
--   transformation of a to b here, but the function getBFst' tries to give
--   about <i>O(log n)</i> complexity The Vector (a, b) must be sorted in
--   ascending order here for the algorithm to be used correctly. For this
--   you can use the following functions <a>sortFst</a> and
--   <a>sortFstV</a>.
--   
--   b before Vector (a, b) in the type definition of the <a>getBFst</a>
--   must be a <tt>defaultValue</tt> for 'case' above.
--   
--   Vector (a, b) corresponds to
--   
--   <pre>
--   a1 -&gt; b1
--   a2 -&gt; b2
--   a3 -&gt; b3
--   ...
--   an -&gt; bn
--   </pre>
getBFst' :: (Ord a) => b -> Vector (a, b) -> a -> b

-- | The function that uses special kind of bisection to effectively
--   transform the [a] to [b] with instead of simply use
--   
--   <pre>
--   case var of
--     a1 -&gt; b1
--     a2 -&gt; b2
--     a3 -&gt; b3
--     ...
--     an -&gt; bn
--     _  -&gt; defaultValue
--   </pre>
--   
--   The function 'map (f (case var of ...)) [a]' gives the <i>O(n*m)</i>
--   coplexity of the transformation of [a] to [b] here where m is the
--   length of the [a] (and [b] respectively here), but the function
--   <a>getBFst</a> tries to give about <i>O(m*log n)</i> complexity The
--   Vector (a, b) must be sorted in ascending order here for the algorithm
--   to be used correctly. For this you can use the following functions
--   <a>sortFst</a> and <a>sortFstV</a>. If m &gt;&gt; n than the function
--   gives more efficiency. Even otherwise, it can be used to simplify the
--   procedure for optimizing the code for transformation of the list data.
--   
--   b after Vector (a, b) in the type definition of the <a>getBFst</a>
--   must be a defaultValue for 'case' above.
--   
--   Vector (a, b) corresponds to
--   
--   <pre>
--   a1 -&gt; b1
--   a2 -&gt; b2
--   a3 -&gt; b3
--   ...
--   an -&gt; bn
--   </pre>
getBFst :: (Ord a) => Vector (a, b) -> b -> [a] -> [b]

-- | The function that uses special kind of bisection to effectively
--   transform the Vector a to Vector b with instead of simply use
--   
--   <pre>
--   case var of
--     a1 -&gt; b1
--     a2 -&gt; b2
--     a3 -&gt; b3
--     ...
--     an -&gt; bn
--     _  -&gt; defaultValue
--   </pre>
--   
--   The function 'V.map (f (case var of ...)) [a]' gives the <i>O(n*m)</i>
--   coplexity of the transformation of Vector a to Vector b here where m
--   is the length of the Vector a (and Vector b respectively here), but
--   the function <a>getBFstV</a> tries to give about <i>O(m*log n)</i>
--   complexity The Vector (a, b) must be sorted in ascending order here
--   for the algorithm to be used correctly. For this you can use the
--   following functions <a>sortFst</a> and <a>sortFstV</a>. If m &gt;&gt;
--   n than the function gives more efficiency. Even otherwise, it can be
--   used to simplify the procedure for optimizing the code for
--   transformation of the Vector data.
--   
--   b after Vector (a, b) in the type definition of the <a>getBFstV</a>
--   must be a defaultValue for case above.
--   
--   Vector (a, b) corresponds to
--   
--   <pre>
--   a1 -&gt; b1
--   a2 -&gt; b2
--   a3 -&gt; b3
--   ...
--   an -&gt; bn
--   </pre>
getBFstV :: (Ord a) => Vector (a, b) -> b -> Vector a -> Vector b

-- | Function that sorts a list of (a, b) tuples by the first argument
--   (<tt>a</tt> must be an instance of class Ord) and is inspired by
--   Data.List.sort function (the last one can be used for sorting the (a,
--   b) tuples where both the types of a and b have instances of the class
--   Ord). It is inspired by the work:
--   <a>https://wiki.haskell.org/Introduction</a>
sortFst :: (Ord a) => [(a, b)] -> [(a, b)]

-- | Function that prepares the list of (a, b) tuples representing the
--   
--   <pre>
--   case var of 
--     a1 -&gt; b1
--     a2 -&gt; b2
--     a3 -&gt; b3
--      ...
--     an -&gt; bn
--     _  -&gt; defaultValue
--   </pre>
--   
--   for usage in the <a>getBFst</a> and <a>getBFstV</a> functions.
--   <tt>a</tt> must be an instance of class Ord.
--   
--   The resulting vector has for every <tt>a</tt> only one element, which
--   was the first in the list of tuples (a, b) after sorting by
--   <a>sortFst</a> function.
sortFstV :: (Ord a) => [(a, b)] -> Vector (a, b)

-- | The function that is used to filter a list [(a, b)] of the
--   corresponding values for getFstB' to obtain the Vector (a, b) such
--   that the b element for the sequence of pairs (a, b) with the same a is
--   selected by the predicate p and is not necessarily the first one as it
--   is for the getFstB' function and its successors by default.
filterP :: (Ord a) => ((a, b) -> Bool) -> [(a, b)] -> Vector (a, b)
