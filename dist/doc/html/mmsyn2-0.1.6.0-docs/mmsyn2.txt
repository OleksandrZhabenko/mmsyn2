-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | The library that can be used for multiple (Ord a) => a -> b transformations
--   
--   The library that can be used for optimization or another
--   representation of multiple (Ord a) =&gt; a -&gt; b transformations
@package mmsyn2
@version 0.1.6.0

module CaseBi

-- | The function that can be used instead of the 'case ... of' function
--   
--   <pre>
--   case var of
--     a1 -&gt; b1
--     a2 -&gt; b2
--     a3 -&gt; b3
--     ...
--     an -&gt; bn
--     _  -&gt; defaultValue
--   </pre>
--   
--   If we follow a lot of teaching materials that explain the workflow of
--   the construction we think that the complexity of it is about
--   <i>O(n)</i> for the transformation of <tt>a</tt> to <tt>b</tt> here.
--   David Feuer (david.feuer (at) gmail.com) said that 'case ... of' is
--   already optimized in GHC. Some benchmarks show that its behaviour
--   tends to be about of <i>O(log n)</i> complexity, the same as the
--   proposed function getBFst'. Nevertheless, the last one shows better
--   performance in some situations, is rather general and can be used for
--   another data representation. Therefore, it can be preferred in some
--   situations. getBFst' uses binary search algorithm and a Vector (a, b)
--   as somewhat like a complicated filter or like a special sieve. The
--   <tt>Vector (a, b)</tt> must be sorted in ascending order here for the
--   algorithm to be used correctly. For this you can use the following
--   functions <a>sortFst</a> and <a>sortFstV</a>.
--   
--   <tt>b</tt> before <tt>Vector (a, b)</tt> in the tuple in the type
--   definition of the <a>getBFst</a> must be a <tt>defaultValue</tt> for
--   'case' above.
--   
--   <tt>Vector (a, b)</tt> corresponds to
--   
--   <pre>
--   a1 -&gt; b1
--   a2 -&gt; b2
--   a3 -&gt; b3
--   ...
--   an -&gt; bn
--   </pre>
getBFst' :: (Ord a) => (b, Vector (a, b)) -> a -> b

-- | The function that uses special kind of bisection to effectively
--   transform the <tt>[a]</tt> to <tt>[b]</tt> instead of simply use
--   
--   <pre>
--   case var of
--     a1 -&gt; b1
--     a2 -&gt; b2
--     a3 -&gt; b3
--     ...
--     an -&gt; bn
--     _  -&gt; defaultValue
--   </pre>
--   
--   The <tt>Vector (a, b)</tt> must be sorted in ascending order here for
--   the algorithm to be used correctly. For this you can use the following
--   functions <a>sortFst</a> and <a>sortFstV</a>. The function can be used
--   to simplify the procedure for optimizing the code for transformation
--   of the list data or to represent the data in another way.
--   
--   <tt>b</tt> after <tt>Vector (a, b)</tt> in the type definition of the
--   <a>getBFst</a> must be a <tt>defaultValue</tt> for 'case' above.
--   
--   <tt>Vector (a, b)</tt> corresponds to
--   
--   <pre>
--   a1 -&gt; b1
--   a2 -&gt; b2
--   a3 -&gt; b3
--   ...
--   an -&gt; bn
--   </pre>
getBFst :: (Ord a) => Vector (a, b) -> b -> [a] -> [b]

-- | The function that uses special realization of the binary search to
--   effectively transform the <tt>Vector a</tt> to <tt>Vector b</tt>
--   instead of simply use
--   
--   <pre>
--   case var of
--     a1 -&gt; b1
--     a2 -&gt; b2
--     a3 -&gt; b3
--     ...
--     an -&gt; bn
--     _  -&gt; defaultValue
--   </pre>
--   
--   The <tt>Vector (a, b)</tt> must be sorted in ascending order here for
--   the algorithm to be used correctly. For this you can use the following
--   functions <a>sortFst</a> and <a>sortFstV</a>. it can be used to
--   simplify the procedure for optimizing the code for transformation of
--   the Vector data.
--   
--   <tt>b</tt> after <tt>Vector (a, b)</tt> in the type definition of the
--   <a>getBFstV</a> must be a <tt>defaultValue</tt> for 'case' above.
--   
--   <tt>Vector (a, b)</tt> corresponds to
--   
--   <pre>
--   a1 -&gt; b1
--   a2 -&gt; b2
--   a3 -&gt; b3
--   ...
--   an -&gt; bn
--   </pre>
getBFstV :: (Ord a) => Vector (a, b) -> b -> Vector a -> Vector b

-- | Function that sorts a list of <tt>(a, b)</tt> tuples by the first
--   argument and is inspired by Data.List.sort function (the last one can
--   be used for sorting the <tt>(a, b)</tt> tuples where both the types of
--   <tt>a</tt> and <tt>b</tt> have instances of the class Ord). It is
--   inspired by the work: <a>https://wiki.haskell.org/Introduction</a>
sortFst :: (Ord a) => [(a, b)] -> [(a, b)]

-- | Function that prepares the list of <tt>(a, b)</tt> tuples representing
--   the
--   
--   <pre>
--   case var of 
--     a1 -&gt; b1
--     a2 -&gt; b2
--     a3 -&gt; b3
--      ...
--     an -&gt; bn
--     _  -&gt; defaultValue
--   </pre>
--   
--   for usage in the <a>getBFst</a> and <a>getBFstV</a> functions.
--   
--   The resulting vector has for every <tt>a</tt> only one element, which
--   was the first in the list of tuples <tt>(a, b)</tt> after sorting by
--   <a>sortFst</a> function.
sortFstV :: (Ord a) => [(a, b)] -> Vector (a, b)

-- | The function that is used to filter <tt>[(a, b)]</tt> of the
--   corresponding values for getFstB' to obtain the <tt>Vector (a, b)</tt>
--   such that the <tt>b</tt> element for the sequence of pairs <tt>(a,
--   b)</tt> with the same <tt>a</tt> is selected by the predicate
--   <tt>p</tt> and is not necessarily the first one as it is for the
--   getFstB' function and its successors by default.
filterP :: (Ord a) => ((a, b) -> Bool) -> [(a, b)] -> Vector (a, b)
