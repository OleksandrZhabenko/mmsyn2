<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>CaseBi</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/CaseBi.html">Source</a></li><li><a href="/package/mmsyn2-0.1.6.0">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">mmsyn2-0.1.6.0: The library that can be used for multiple (Ord a) =&gt; a -&gt; b transformations</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">CaseBi</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Function that can be used instead of 'case ... of' construction</a></li><li><a href="#g:2">Additional functions that are used to sort a list of pairs (which can be obtained e. g. by Prelude.zip)</a><ul><li><a href="#g:3">Function that can be used for changing the Vector (a, b) during its creation </a></li></ul></li></ul></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:getBFst-39-">getBFst'</a> :: Ord a =&gt; (b, Vector (a, b)) -&gt; a -&gt; b</li><li class="src short"><a href="#v:getBFst">getBFst</a> :: Ord a =&gt; Vector (a, b) -&gt; b -&gt; [a] -&gt; [b]</li><li class="src short"><a href="#v:getBFstV">getBFstV</a> :: Ord a =&gt; Vector (a, b) -&gt; b -&gt; Vector a -&gt; Vector b</li><li class="src short"><a href="#v:sortFst">sortFst</a> :: Ord a =&gt; [(a, b)] -&gt; [(a, b)]</li><li class="src short"><a href="#v:sortFstV">sortFstV</a> :: Ord a =&gt; [(a, b)] -&gt; Vector (a, b)</li><li class="src short"><a href="#v:filterP">filterP</a> :: Ord a =&gt; ((a, b) -&gt; Bool) -&gt; [(a, b)] -&gt; Vector (a, b)</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Function that can be used instead of 'case ... of' construction</h1></a><div class="top"><p class="src"><a id="v:getBFst-39-" class="def">getBFst'</a> <a href="src/CaseBi.html#getBFst%27" class="link">Source</a> <a href="#v:getBFst-39-" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: Ord a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (b, Vector (a, b))</td><td class="doc"><p><code>b</code> is a default value that can be substituted if there is no correspendence in the set of <code>(a, b)</code> tuples (the <code>otherwise</code> or irrefutable pattern analogue).
 ^ Vector of the <code>(a, b)</code> tuples that must be sorted in ascending order for the first argument. If there are several pairs <code>(a, b)</code> with the same <code>a</code>, 
 ^ the function gives a resulting <code>b</code> as if there is only the first one</p></td></tr><tr><td class="src">-&gt; a</td><td class="doc"><p>an element for which the corresponding resulting b must be found</p></td></tr><tr><td class="src">-&gt; b</td><td class="doc"><p>the result</p></td></tr></table></div><div class="doc"><p>The function that can be used instead of the 'case ... of' function</p><pre>case var of
  a1 -&gt; b1
  a2 -&gt; b2
  a3 -&gt; b3
  ...
  an -&gt; bn
  _  -&gt; defaultValue</pre><p>If we follow a lot of teaching materials that explain the workflow of the construction we think that the complexity of it is about <em>O(n)</em> for the transformation of <code>a</code> to <code>b</code> here. 
 David Feuer (david.feuer (at) gmail.com) said that 'case ... of' is already optimized in GHC. Some benchmarks show that its behaviour  tends to be about of <em>O(log n)</em> complexity, the same as
 the proposed function getBFst'. Nevertheless, the last one shows better performance in some situations, is rather general and can be used for another data representation.
 Therefore, it can be preferred in some situations. getBFst' uses binary search algorithm and a Vector (a, b) as somewhat like a complicated filter or like a special sieve.
 The <code>Vector (a, b)</code> must be sorted in ascending order here for the algorithm to be used correctly. For this you can use 
 the following functions <code><a href="CaseBi.html#v:sortFst" title="CaseBi">sortFst</a></code> and <code><a href="CaseBi.html#v:sortFstV" title="CaseBi">sortFstV</a></code>. </p><p><code>b</code> before <code>Vector (a, b)</code> in the tuple in the type definition of the <code><a href="CaseBi.html#v:getBFst" title="CaseBi">getBFst</a></code> must be a <code>defaultValue</code> for 'case' above. </p><p><code>Vector (a, b)</code> corresponds to </p><pre> a1 -&gt; b1
 a2 -&gt; b2
 a3 -&gt; b3
 ...
 an -&gt; bn</pre></div></div><div class="top"><p class="src"><a id="v:getBFst" class="def">getBFst</a> <a href="src/CaseBi.html#getBFst" class="link">Source</a> <a href="#v:getBFst" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: Ord a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; Vector (a, b)</td><td class="doc"><p>Vector of the <code>(a, b)</code> tuples that must be sorted in ascending order for the first argument</p></td></tr><tr><td class="src">-&gt; b</td><td class="doc"><p>a default value that can be substituted if there is no correspendence in the set of <code>(a, b)</code> tuples (the <code>otherwise</code> or irrefutable pattern analogue)</p></td></tr><tr><td class="src">-&gt; [a]</td><td class="doc"><p>a list of values needed to be transformed accordingly to the correct <code>(a, b)</code> tuple pairs</p></td></tr><tr><td class="src">-&gt; [b]</td><td class="doc"><p>the resulting list</p></td></tr></table></div><div class="doc"><p>The function that uses special kind of bisection to effectively transform the <code>[a]</code> to <code>[b]</code> instead of simply use </p><pre>case var of
  a1 -&gt; b1
  a2 -&gt; b2
  a3 -&gt; b3
  ...
  an -&gt; bn
  _  -&gt; defaultValue</pre><p>The <code>Vector (a, b)</code> must be sorted in ascending order here for the algorithm to be used correctly. For this you can use 
 the following functions <code><a href="CaseBi.html#v:sortFst" title="CaseBi">sortFst</a></code> and <code><a href="CaseBi.html#v:sortFstV" title="CaseBi">sortFstV</a></code>. The function can be used to simplify the procedure for optimizing the code for transformation of the list data 
 or to represent the data in another way.</p><p><code>b</code> after <code>Vector (a, b)</code> in the type definition of the <code><a href="CaseBi.html#v:getBFst" title="CaseBi">getBFst</a></code> must be a <code>defaultValue</code> for 'case' above. </p><p><code>Vector (a, b)</code> corresponds to </p><pre> a1 -&gt; b1
 a2 -&gt; b2
 a3 -&gt; b3
 ...
 an -&gt; bn</pre></div></div><div class="top"><p class="src"><a id="v:getBFstV" class="def">getBFstV</a> <a href="src/CaseBi.html#getBFstV" class="link">Source</a> <a href="#v:getBFstV" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: Ord a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; Vector (a, b)</td><td class="doc"><p>Vector of the <code>(a, b)</code> tuples that are sorted in ascending order for the first argument</p></td></tr><tr><td class="src">-&gt; b</td><td class="doc"><p>a default value that can be substituted if there is no correspendence in the set of <code>(a, b)</code> tuples (the <code>otherwise</code> or irrefutable pattern analogue)</p></td></tr><tr><td class="src">-&gt; Vector a</td><td class="doc"><p>a Vector needed to be transformed accordingly to the correct <code>(a, b)</code> tuple pairs</p></td></tr><tr><td class="src">-&gt; Vector b</td><td class="doc"><p>the resulting Vector</p></td></tr></table></div><div class="doc"><p>The function that uses special realization of the binary search to effectively transform the <code>Vector a</code> to <code>Vector b</code> instead of simply use </p><pre>case var of
  a1 -&gt; b1
  a2 -&gt; b2
  a3 -&gt; b3
  ...
  an -&gt; bn
  _  -&gt; defaultValue</pre><p>The <code>Vector (a, b)</code> must be sorted in ascending order here for the algorithm to be used correctly. For this you can use 
 the following functions <code><a href="CaseBi.html#v:sortFst" title="CaseBi">sortFst</a></code> and <code><a href="CaseBi.html#v:sortFstV" title="CaseBi">sortFstV</a></code>. it can be used to simplify the procedure for optimizing the code for transformation of the Vector data.</p><p><code>b</code> after <code>Vector (a, b)</code> in the type definition of the <code><a href="CaseBi.html#v:getBFstV" title="CaseBi">getBFstV</a></code> must be a <code>defaultValue</code> for 'case' above. </p><p><code>Vector (a, b)</code> corresponds to </p><pre> a1 -&gt; b1
 a2 -&gt; b2
 a3 -&gt; b3
 ...
 an -&gt; bn</pre></div></div><a href="#g:2" id="g:2"><h1>Additional functions that are used to sort a list of pairs (which can be obtained e. g. by Prelude.zip)</h1></a><div class="top"><p class="src"><a id="v:sortFst" class="def">sortFst</a> :: Ord a =&gt; [(a, b)] -&gt; [(a, b)] <a href="src/CaseBi.html#sortFst" class="link">Source</a> <a href="#v:sortFst" class="selflink">#</a></p><div class="doc"><p>Function that sorts a list of <code>(a, b)</code> tuples by the first argument 
 and is inspired by Data.List.sort function (the last one can be used for sorting the <code>(a, b)</code> tuples where both the types of <code>a</code> and <code>b</code>
 have instances of the class Ord). It is inspired by the work: <a href="https://wiki.haskell.org/Introduction">https://wiki.haskell.org/Introduction</a></p></div></div><div class="top"><p class="src"><a id="v:sortFstV" class="def">sortFstV</a> <a href="src/CaseBi.html#sortFstV" class="link">Source</a> <a href="#v:sortFstV" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: Ord a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; [(a, b)]</td><td class="doc"><p>The list of conditions that is then converted to the corresponding Vector</p></td></tr><tr><td class="src">-&gt; Vector (a, b)</td><td class="doc"><p>the resulting sorted Vector that can be used further in getBFst' and its successors.</p></td></tr></table></div><div class="doc"><p>Function that prepares the list of <code>(a, b)</code> tuples representing the </p><pre>case var of 
  a1 -&gt; b1
  a2 -&gt; b2
  a3 -&gt; b3
   ...
  an -&gt; bn
  _  -&gt; defaultValue</pre><p>for usage in the <code><a href="CaseBi.html#v:getBFst" title="CaseBi">getBFst</a></code> and <code><a href="CaseBi.html#v:getBFstV" title="CaseBi">getBFstV</a></code> functions. </p><p>The resulting vector has for every <code>a</code> only one element, which was the first in the list of tuples <code>(a, b)</code> after sorting by <code><a href="CaseBi.html#v:sortFst" title="CaseBi">sortFst</a></code> function.</p></div></div><a href="#g:3" id="g:3"><h2>Function that can be used for changing the Vector (a, b) during its creation </h2></a><div class="top"><p class="src"><a id="v:filterP" class="def">filterP</a> <a href="src/CaseBi.html#filterP" class="link">Source</a> <a href="#v:filterP" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: Ord a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; ((a, b) -&gt; Bool)</td><td class="doc"><p>The predicate <code>p</code> used to select the only one value of <code>b</code> in the pairs <code>(a, b)</code> with the same <code>a</code>. 
 ^ If there are several pairs <code>(a, b)</code> for the same <code>a</code> that satisfies a predicate then the first one is used. For large <code>[(a, b)]</code> 
 ^ it can be rather complex.</p></td></tr><tr><td class="src">-&gt; [(a, b)]</td><td class="doc"><p>The list of <code>(a, b)</code> sorted in the ascending order by the first element a (e. g. by the <code><a href="CaseBi.html#v:sortFst" title="CaseBi">sortFst</a></code> function)</p></td></tr><tr><td class="src">-&gt; Vector (a, b)</td><td class="doc"><p>The resulting filtered <code>Vector (a, b)</code> that can be used for getFstB' and its successor functions.</p><p>Example: </p><pre>filterP (\(t, w) -&gt; (t == &quot;1&quot;) || (w &gt; 'f')) . sortFst $ [(&quot;1&quot;,'a'),(&quot;4a&quot;,'k'),(&quot;4a&quot;,'b'),(&quot;4a&quot;,'c'),(&quot;4a&quot;,'d'),(&quot;4a&quot;,'e'),(&quot;b7&quot;,'c'),(&quot;b7&quot;,'k')] = [(&quot;1&quot;,'a'),(&quot;4a&quot;,'k'),(&quot;b7&quot;,'k')]</pre></td></tr></table></div><div class="doc"><p>The function that is used to filter <code>[(a, b)]</code> of the corresponding values for getFstB' to obtain the <code>Vector (a, b)</code> 
 such that the <code>b</code> element for the sequence of pairs <code>(a, b)</code> with the same <code>a</code> is selected by the predicate <code>p</code> and is not necessarily the first one 
 as it is for the getFstB' function and its successors by default.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.20.0</p></div></body></html>